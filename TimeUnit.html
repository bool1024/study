<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<link rel="stylesheet" type="text/css" href="file:///${exe}/scripts/highlight.styles/${SyntaxHighlightStyleName}.css" />
		<style>
			body, table{font-family: 微软雅黑}
			
			table{border-collapse: collapse; border: 1px solid gray; border-width: 2px 1px 2px 1px;}
			th{border: 1px solid gray; padding: 4px; background-color: #ddd;}
			td{border: 1px solid gray; padding: 4px;}
			tr:nth-child(2n){background-color: #f8f8f8;}
			pre{border: 2px solid #d6d6d6; padding: 0px; border-radius: 3px;}
		</style>
	</head>
	<body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">
		<div><span style="font-size: x-large; font-weight: bold;">TimeUnit是什么？</span>
		</div>
		<div>TimeUnit是java.util.concurrent包下面的一个类，TimeUnit提供了可读性更好的线程暂停操作，通常用来替换Thread.sleep()，在很长一段时间里Thread的sleep()方法作为暂停线程的标准方式，几乎所有的Java程序员都熟悉它，事实上sleep方法本身也很常用而且出现在很多面试中。如果你已经使用过Thread.sleep()，那么你一定熟知<span style="color: rgb(255, 0, 0);">它是一个静态方法，暂停线程时它不会释放锁</span>，该方法会抛出InterrupttedException异常（如果有线程中断了当前线程）。但是我们很多人没有注意的一个潜在的问题就是它的可读性。Thread.sleep()是一个重载方法，可以接收长整形毫秒和长整形的纳秒参数，这样对程序员造成的一个问题就是很难知道当前线程到底是睡眠了多少秒、分、小时或天。例如：
		</div>
		<div>
			<pre>
<code id="ID_162FA577CB7" class="lang-java hljs">Thread.sleep(<span class="hljs-number">2400000</span>);</code></pre>
			<div>粗略一看，很难计算出当前线程是等待多长时间。对大多数程序员来说这种写法的可读性是很差的，需要把毫秒转换成秒和分。下面的例子可读性稍好一点：
			</div>
		</div>
		<div>
			<pre>
<code id="ID_162FA5961FB" class="lang-java hljs">Thread.sleep(<span class="hljs-number">4</span>*<span class="hljs-number">60</span>*<span class="hljs-number">1000</span>);</code></pre>
			<div>这比前面那个例子已经好多了，但是仍然不是最好的。TimeUnit类解决了这个问题，通过制定DAYS、HOURS、MINUTES、SECONDS、MILLISECONDS和NANOSECONDS。java.util.concurrent.TimeUnit是java枚举应用场景中最好的例子之一，所有TimeUnit都是枚举实例，下面看看线程睡眠4分钟用TimeUnit是如何使用的：
			</div>
		</div>
		<div>
			<pre>
<code id="ID_162FA5C0EC2" class="lang-java hljs">TimeUnit.MINUTES.sleep(<span class="hljs-number">4</span>);</code></pre>
			<div>类似可以采用秒、分、小时级别来暂停当前线程。可以看出这比Thread的sleep方法的可读性好多了。TimeUnit.sleep()内部调用的Thread.sleep()也会抛出InterruptedException。
			</div>
		</div>
		<div><br />
		</div>
		<div>除了sleep的功能外，TimeUnit还提供了便捷方法用于把时间转换成不同单位，例如，如果你想把秒转换成毫秒，可以使用下面的代码：
		</div>
		<div>
			<pre>
<code id="ID_162FA5EC530" class="lang-java hljs">TimeUnit.SECONDS.toMillis(<span class="hljs-number">44</span>);</code></pre>
			<div>它将返回44000
			</div>
		</div>
		<div><br />
		</div>
		<div><br />
		</div>
		<div><span style="font-size: x-large; font-weight: bold;">TimeUnit.sleep() vs Thread.sleep()</span>
		</div>
		<div>目前我们讨论使用<span style="color: rgb(255, 0, 0);">TimeUnit的好处是提高了可读性</span>，但是有时候觉得其他方法更好，因为Thread.sleep()伴随java很早就出现了，几乎所有程序员都知道Thread.sleep()，都知道是将当前线程暂停，而对TimeUnit并不太熟悉。原因有两个：
		</div>
		<div>
			<ol>
				<li>对比起Thread.sleep()，TimeUnit不是很常用
				</li>
				<li>TimeUnit.sleep()不在Thread类中，就像wait和notify同样不在Thread中，这需要一段时间才能被采用，并成为一个标准的方式
				</li>
			</ol>
			<div>总结：<span style="color: rgb(255, 0, 0);">在需要用sleep()方法的地方最好使用TimeUnit.sleep()方法类代替</span>。它不仅可以提高代码的可读性，而且能更加熟悉java.util.concurrent包，因为TimeUnit在并发编程中也是一个关键API。
			</div>
		</div>
		<div><br />
		</div>
		<div><span style="font-size: x-large; font-weight: bold;">TimeUnit常用的颗粒度</span>
		</div>
		<div>
			<pre>
<code id="ID_162FA6BFF55" class="lang-java hljs">TimeUnit.DAYS              <span class="hljs-comment">//天</span>
TimeUnit.HOURS             <span class="hljs-comment">//小时</span>
TimeUnit.MINUTES           <span class="hljs-comment">//分钟</span>
TimeUnit.SECONDS           <span class="hljs-comment">//秒</span>
TimeUnit.MILLISECONDS      <span class="hljs-comment">//毫秒</span>
TimeUnit.MICROSECONDS      <span class="hljs-comment">//微秒</span>
TimeUnit.NANOSECONDS       <span class="hljs-comment">//纳秒</span></code></pre>
			<div><br />
			</div>
		</div>
	</body>
</html>
