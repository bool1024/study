<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<link rel="stylesheet" type="text/css" href="file:///${exe}/scripts/highlight.styles/${SyntaxHighlightStyleName}.css" />
		<style>
			table{border-collapse: collapse; border: 1px solid gray; border-width: 2px 1px 2px 1px;}
			th{border: 1px solid gray; padding: 4px; background-color: #ddd;}
			td{border: 1px solid gray; padding: 4px;}
			tr:nth-child(2n){background-color: #f8f8f8;}
			pre{border: 2px solid #d6d6d6; padding: 0px; border-radius: 3px;}
		</style>
	</head>
	<body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">
		<div><span style="font-family: 微软雅黑; font-weight: bold; "><span style="font-size: 18pt">一.Java语言的新特性</span></span>
		</div>
		<div><span style="font-family: 微软雅黑; font-size: large; font-weight: bold;">1.Lambda表达式和函数式接口</span>
		</div>
		<div><span style="font-family: 微软雅黑;">Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当做数据处理，函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是Java开发者没有哦选择，只能使用匿名内部类代替Lambda表达式。</span>
		</div>
		<div><span style="font-family: 微软雅黑;"><br /></span>
		</div>
		<div><span style="font-family: 微软雅黑;">Lambda的设计耗费了很多时间和很大的社区力量，最终找到一种折中的实现方案，可以实现简介而紧凑的语言结构。最简单的Lambda表达式可由逗号分隔的参数列表、-&gt;符号和语句块组成，例如：</span>
		</div>
		<pre>
<code id="ID_1636D268D80" class="lang-java hljs">Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>).forEach(e -&gt; System.out.println(e));</code></pre>
		<div>
			<div style="font-family: 微软雅黑; ">在上面这个代码中的参数e的类型是由编译器推理得出的，可以显式指定该参数的类型，例如：
			</div>
			<div style="font-family: 微软雅黑; ">
				<pre>
<code id="ID_16367F346AE" class="lang-java hljs">Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>).forEach((String e) -&gt; System.out.println(e));</code></pre>
				<div>如果Lambda表达式需要更复杂的语句块，可以使用花括号将该语句括起来，类似于Java中的函数体，例如：
				</div>
			</div>
			<div style="font-family: 微软雅黑; ">
				<pre>
<code id="ID_16367F491E0" class="lang-java hljs">Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>).forEach(e -&gt; {
    System.out.println(e);
});</code></pre>
				<div>Lambda表达式可以引用成员和局部变量（会将这些变量隐式地转换成<span style="color: rgb(255, 0, 0); ">final</span>的），例如下面两个代码块的效果完全相同：
				</div>
			</div>
			<div style="font-family: 微软雅黑; ">
				<pre>
<code id="ID_16367F72C11" class="lang-java hljs">String separator = <span class="hljs-string">","</span>;
Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>).forEach((String e) -&gt; System.out.println(e + separator));</code></pre>
				<div>和
				</div>
			</div>
			<div style="font-family: 微软雅黑; ">
				<pre>
<code id="ID_16367F7B82E" class="lang-java hljs"><span class="hljs-keyword">final</span> String separator = <span class="hljs-string">","</span>;
Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>).forEach((String e) -&gt; System.out.println(e + separator));</code></pre>
				<div>Lambda表达式有返回值，返回值的类型也由编译器推理了得出。如果Lambda表达式中的语句块只有一行，则可以不用使用return语句，下列两个代码块的效果相同：
				</div>
			</div>
			<div style="font-family: 微软雅黑; ">
				<pre>
<code id="ID_16367FA0C85" class="lang-java hljs">Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>).sort((e1, e2) -&gt; e1.compareTo(e2));</code></pre>
				<div>和
				</div>
			</div>
			<div style="font-family: 微软雅黑; ">
				<pre>
<code id="ID_16367FB0E96" class="lang-java hljs">Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>).sort((e1, e2) -&gt; {
    <span class="hljs-keyword">int</span> result = e1.compareTo(e2);
    <span class="hljs-keyword">return</span> result;
});</code></pre>
				<div>Lambda的设计者们为了让现有的功能与Lambda的、表达式良好兼容，考虑了很多方法，于是产生了<span style="color: rgb(255, 0, 0);">函数接口</span>这个概念。<span style="color: rgb(255, 0, 0);">函数接口指的是只有一个函数的接口，这样的接口可以隐式转换为Lambda表达式</span>。<span style="color: rgb(0, 255, 0);">java.lang.Runnable和java.util.concurrent.Callable是函数式接口的最佳例子</span>。在实践中，<span style="color: rgb(255, 0, 0);">函数式接口非常脆弱：只要某个开发者在该接口中添加一个函数，则该接口就不再是函数式接口进而导致编译失败</span>。为了克服这种代码层面的脆弱性，并显式说明某个接口是函数式接口，Java 8提供了一个特殊的注解<span style="color: rgb(255, 0, 0);">@FunctionalInterface</span>（Java库中的所有相关接口都已经带有这个注解了），举个简单的函数式接口的定义：
				</div>
			</div>
			<div style="font-family: 微软雅黑; ">
				<pre>
<code id="ID_16368018D8B" class="lang-java hljs"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Functional</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;
}
</code></pre>
				<div>不过有一点需要注意，默认方法和静态方法不会破坏函数式接口的定义，因此如下的代码是非法的：
				</div>
			</div>
			<div style="font-family: 微软雅黑; ">
				<pre>
<code id="ID_16368040CEF" class="lang-java hljs"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Functional</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;
    
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultMethod</span><span class="hljs-params">()</span></span>{
        
    }
}
</code></pre>
				<div><br />
				</div>
			</div>
			<div style="font-family: 微软雅黑; "><span style="font-size: large; font-weight: bold;">2.接口的默认方法和静态方法</span>
			</div>
			<div style="font-family: 微软雅黑; ">Java 8使用了两个新概念扩展了接口的含义：默认方法和静态方法。默认方法使得接口优点类似traits，不过要实现的目标不一样。默认方法使得开发者可以在不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。
			</div>
			<div style="font-family: 微软雅黑; "><br />
			</div>
			<div style="font-family: 微软雅黑; ">默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，示例如下：
			</div>
			<div style="font-family: 微软雅黑; ">
				<pre>
<code id="ID_1636811D445" class="lang-java hljs"><ol><li><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Defaultable</span></span>{</li><li>    <span class="hljs-function"><span class="hljs-keyword">default</span> String <span class="hljs-title">notRequired</span><span class="hljs-params">()</span></span>{</li><li>        <span class="hljs-keyword">return</span> <span class="hljs-string">"Default implementation"</span>;</li><li>    }</li><li>}</li><li>    </li><li><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultableImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Defaultable</span></span>{</li><li>        </li><li>}</li><li>    </li><li><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OverridableImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Defaultable</span></span>{</li><li>    <span class="hljs-meta">@Override</span></li><li>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">notRequired</span><span class="hljs-params">()</span> </span>{</li><li>        <span class="hljs-keyword">return</span> <span class="hljs-string">"Overridden implementaton"</span>;</li><li>    }</li><li>}</li></ol></code></pre>
				<div>Defaultable接口使用关键字<span style="color: rgb(255, 0, 0);">default</span>定义了一个默认方法notRequired()。DefaultableImpl类实现了这个接口，同时默认继承了这个接口中的默认方法；OverridableImpl类也实现了这个接口，但覆写了该接口的默认方法，并提供了一个不同的实现。
				</div>
			</div>
			<div style="font-family: 微软雅黑; "><br />
			</div>
			<div style="font-family: 微软雅黑; ">Java 8带来的另一个有趣的特性是在接口中可以定义静态方法，示例如下：
			</div>
			<div>
				<pre style="font-family: 微软雅黑; ">
<code id="ID_163682AD392" class="lang-java hljs"><ol><li><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DefaultableFactory</span></span>{</li><li>    <span class="hljs-function"><span class="hljs-keyword">static</span> Defaultable <span class="hljs-title">create</span><span class="hljs-params">(Supplier&lt;Defaultable&gt; supplier)</span></span>{</li><li>        <span class="hljs-keyword">return</span> supplier.get();</li><li>    }</li><li>}</li></ol></code></pre>
				<div style="font-family: 微软雅黑; ">下面的代码片段整合了默认方法和静态方法的使用场景：
				</div>
				<div style="font-family: 微软雅黑; ">
					<pre>
<code id="ID_163682D57E6" class="lang-java hljs"><ol><li><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{</li><li>    Defaultable defaultable = DefaultableFactory.create(DefaultableImpl::<span class="hljs-keyword">new</span>);</li><li>    System.out.println(defaultable.notRequired());</li><li>    defaultable = DefaultableFactory.create(OverridableImpl::<span class="hljs-keyword">new</span>);</li><li>    System.out.println(defaultable.notRequired());</li><li>}</li></ol></code></pre>
					<div>运行结果如下：
					</div>
				</div>
				<div style="font-family: 微软雅黑; ">
					<div><span style="font-family: Consolas; font-size: 12pt">Default implementation</span>
					</div>
					<div><span style="font-family: Consolas; font-size: 12pt">Overridden implementaton</span>
					</div>
				</div>
				<div style="font-family: 微软雅黑; "><span style="font-family: Consolas; font-size: 12pt"><br /></span>
				</div>
				<div><span style="font-family: 微软雅黑"><span style="font-size: 12pt; ">由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给java.util.Collection接口添加新方法，如stream()、parallelStream()、forEach()和removeIf()等等。</span></span>
				</div>
				<div><span style="font-family: 微软雅黑"><span style="font-size: 12pt; "><br /></span></span>
				</div>
				<div><span style="font-family: 微软雅黑"><span style="font-size: 12pt; "><br /></span></span>
				</div>
				<div><span style="font-family: 微软雅黑"><span style="font-size: 13.5pt"><strong>3.方法引用</strong></span></span>
				</div>
				<div><span style="font-family: 微软雅黑">方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。</span>
				</div>
				<pre>
<code id="ID_163683B5AA0" class="lang-java hljs"><ol><li><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>{</li><li>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Car <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Supplier&lt;Car&gt; supplier)</span></span>{</li><li>        <span class="hljs-keyword">return</span> supplier.get();</li><li>    }</li><li>        </li><li>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">collide</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Car car)</span></span>{</li><li>        System.out.println(<span class="hljs-string">"Collided"</span> + car.toString());</li><li>    }</li><li>        </li><li>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">follow</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Car another)</span></span>{</li><li>        System.out.println(<span class="hljs-string">"Following the"</span> + another.toString());</li><li>    }</li><li>        </li><li>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">repair</span><span class="hljs-params">()</span></span>{</li><li>        System.out.println(<span class="hljs-string">"Repaired"</span> + <span class="hljs-keyword">this</span>.toString());</li><li>    }</li><li>}</li></ol></code></pre>
				<div><span style="font-family: 微软雅黑">第一种方法引用的类型是构造器引用，语法是Class::new。注意：这个构造器没有参数：</span>
				</div>
				<pre>
<code id="ID_163683E7B69" class="lang-java hljs"><span class="hljs-keyword">final</span> Car car = Car.create(Car::<span class="hljs-keyword">new</span>);
<span class="hljs-keyword">final</span> List&lt;Car&gt; cars = Arrays.asList(car);</code></pre>
				<div><span style="font-family: 微软雅黑">第二种方法引用的类型是静态方法引用，语法是Class::static_method。注意，这个方法接受一个Car类型的参数：</span>
				</div>
				<div><span style="font-family: 微软雅黑">
					<pre>
<code id="ID_1636B9A8982" class="lang-java hljs">cars.forEach(Car::collide);</code></pre>
					<div>第三种方法引用的类型是某个类的成员方法的引用，语法是Class::method。注意，这个方法没有定义入参：
					</div></span>
					<pre>
<code id="ID_1636B9B7314" class="lang-java hljs">cars.forEach(Car::repair);</code></pre>
					<div><span style="font-family: 微软雅黑">第四种方法引用的类型是某个实例对象的成员方法的引用，语法是instance::method。注意，这个方法接受一个Car类型的参数：</span>
					</div>
				</div>
				<div><span style="font-family: 微软雅黑">
					<pre>
<code id="ID_1636B9D5F69" class="lang-java hljs"><span class="hljs-keyword">final</span> Car police = Car.create(Car::<span class="hljs-keyword">new</span>);
cars.forEach(police::follow);</code></pre>
					<div>运行上述例子，可以在控制台看到如下输出（Car实例可能不同）
					</div>
					<div>
						<div><span style="font-family: Consolas; font-size: 12pt">CollidedMain$Car@87aac27</span>
						</div>
						<div><span style="font-family: Consolas; font-size: 12pt">RepairedMain$Car@87aac27</span>
						</div>
						<div><span style="font-family: Consolas; font-size: 12pt">Following theMain$Car@87aac27</span>
						</div>
					</div></span>
				</div>
				<div style="font-family: 微软雅黑; ">
				</div>
				<div style="font-family: 微软雅黑; "><span style="font-family: Consolas; font-size: 12pt"><br /></span>
				</div>
				<div><span style="font-family: 微软雅黑; font-size: 13.5pt"><strong>4.重复注解</strong></span>
				</div>
				<div><span style="font-size: 12pt; "><span style="font-family: 微软雅黑">自从Java 5中引入注解以来，这个特性开始变得非常流行，并在各个框架和项目中被广泛使用。不过，<span style="color: #ff0000">注解有一个很大的限制是：在同一个地方不能多次使用同一个注解</span>。Java 8打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解。</span></span>
				</div>
				<div><span style="font-size: 12pt; "><span style="font-family: 微软雅黑"><br /></span></span>
				</div>
				<div><span style="font-size: 12pt; "><span style="font-family: 微软雅黑">在Java 8中使用@Repeatable注解定义重复注解，实际上，这并不是语言层面的改进，而是编译器做的一个trick，底层的技术仍然相同。可以利用下面的代码说明：</span></span>
				</div>
				<pre>
<code id="ID_1636BA924E1" class="lang-java hljs"><ol><li><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;</li><li><span class="hljs-keyword">import</span> java.lang.annotation.Repeatable;</li><li><span class="hljs-keyword">import</span> java.lang.annotation.Retention;</li><li><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;</li><li><span class="hljs-keyword">import</span> java.lang.annotation.Target;</li><li></li><li></li><li><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RepeatingAnnotations</span> </span>{</li><li>    </li><li>    <span class="hljs-meta">@Target</span>(ElementType.TYPE)</li><li>    <span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</li><li>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Filters{</li><li>        Filter[] value();</li><li>    }</li><li>    </li><li>    <span class="hljs-meta">@Target</span>(ElementType.TYPE)</li><li>    <span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</li><li>    <span class="hljs-meta">@Repeatable</span>(Filters.class)</li><li>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Filter{</li><li>        <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;</li><li>    }</li><li>    </li><li>    <span class="hljs-meta">@Filter</span>(<span class="hljs-string">"filter1"</span>)</li><li>    <span class="hljs-meta">@Filter</span>(<span class="hljs-string">"filter2"</span>)</li><li>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Filterable</span></span>{</li><li>        </li><li>    }</li><li>    </li><li>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{</li><li>        <span class="hljs-keyword">for</span>(Filter filter: Filterable.class.getAnnotationsByType(Filter.class)){</li><li>            System.out.println(filter.value());</li><li>        }</li><li>    }</li><li>}</li></ol></code></pre>
				<div><span style="font-family: 微软雅黑">正如我们所见，这里的Filter类使用@Repeatable(Filters.class)注解修饰，而Filters是存放Filter注解的容器，编译器尽量对开发者屏蔽这些细节。这样，Filterable接口可以用两个Filter注解注释（这里并没有提到任何关于Filters的信息）。</span>
				</div>
				<div><span style="font-family: 微软雅黑"><br /></span>
				</div>
				<div><span style="font-family: 微软雅黑">另外，反射API提供了一个新的方法：getAnnotationsByType()，可以返回某个类型的重复注解，例如Filterable.class.getAnnotation(Filters.class)将返回两个Filter实例，输出到控制台的内容如下所示：</span>
				</div>
				<div><span style="font-family: 微软雅黑">
					<div><span style="font-family: Consolas; font-size: 12pt">filter1</span>
					</div>
					<div><span style="font-family: Consolas; font-size: 12pt">filter2</span>
					</div>
					<div><span style="font-family: Consolas; font-size: 12pt"><br /></span>
					</div>
					<div><span style="font-size: 13.5pt"><strong>5.更好的类型推断</strong></span>
					</div>
					<div><span style="font-size: 12pt; ">Java 8编译器在类型推断方面有很大的提升，在很多场景下编译器可以推导出某个参数的数据类型，从而使得代码更为简洁。实例如下：</span>
					</div></span>
					<pre>
<code id="ID_1636BDB3599" class="lang-java hljs"><ol><li><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Value</span>&lt;<span class="hljs-title">T</span>&gt; </span>{</li><li>    </li><li>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">defaultValue</span><span class="hljs-params">()</span></span>{</li><li>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</li><li>    }</li><li>    </li><li>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getOrDefault</span><span class="hljs-params">(T value, T defaultValue)</span></span>{</li><li>        <span class="hljs-keyword">return</span> (value != <span class="hljs-keyword">null</span>) ? value: defaultValue;</li><li>    }</li><li>}</li></ol></code></pre>
					<div><span style="font-family: 微软雅黑">下列代码是Value类型的应用：</span>
					</div>
					<div><span style="font-family: 微软雅黑">
						<pre>
<code id="ID_1636BDEC76E" class="lang-java hljs"><ol><li><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{</li><li>    <span class="hljs-keyword">final</span> Value&lt;String&gt; value = <span class="hljs-keyword">new</span> Value&lt;String&gt;();</li><li>    value.getOrDefault(<span class="hljs-string">"22"</span>, Value.defaultValue());</li><li>}</li></ol></code></pre>
						<div>参数Value.defaultValue()的类型由编译器推导得出，不需要显示指明。在Java 7中这段代码会有编译错误，除非使用Value.&lt;String&gt;defaultValue().
						</div>
						<div><br />
						</div>
						<div><span style="font-size: 13.5pt"><strong>6.拓宽注解的应用场景</strong></span>
						</div>
						<div>Java 8拓宽了注解的应用场景。现在，注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。下面是一些例子：
						</div></span>
						<pre>
<code id="ID_1636BE8210B" class="lang-java hljs"><ol><li><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;</li><li><span class="hljs-keyword">import</span> java.lang.annotation.Retention;</li><li><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;</li><li><span class="hljs-keyword">import</span> java.lang.annotation.Target;</li><li><span class="hljs-keyword">import</span> java.util.ArrayList;</li><li><span class="hljs-keyword">import</span> java.util.Collection;</li><li></li><li></li><li><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Annotations</span> </span>{</li><li>    </li><li>    <span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</li><li>    <span class="hljs-meta">@Target</span>({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})</li><li>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NonEmpty{</li><li>        </li><li>    }</li><li>    </li><li>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Holder</span>&lt;@<span class="hljs-title">NonEmpty</span> <span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> @<span class="hljs-title">NonEmpty</span> <span class="hljs-title">Object</span></span>{</li><li>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> @NonEmpty Exception</span>{</li><li>            </li><li>        }</li><li>    }</li><li>    </li><li>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unused"</span>)</li><li>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{</li><li>        <span class="hljs-keyword">final</span> Holder&lt;String&gt; holder = <span class="hljs-keyword">new</span> <span class="hljs-meta">@NonEmpty</span> Holder&lt;String&gt;();</li><li>        <span class="hljs-meta">@NonEmpty</span> Collection&lt;<span class="hljs-meta">@NonEmpty</span> String&gt; strs = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</li><li>    }</li><li>}</li></ol></code></pre>
						<div><br />
						</div>
					</div>
					<div><br />
					</div>
					<div><span style="font-family: 微软雅黑; font-size: 18pt"><strong>二.Java编译器的新特性</strong></span>
					</div>
					<div><span style="font-family: 微软雅黑; font-size: 13.5pt"><strong>1.参数名称</strong></span>
					</div>
					<div><span style="font-family: 微软雅黑">为了在运行时获得Java程序中方法的参数名称，老一辈的Java程序员必须使用不同方法，例如Paranamer liberary。Java 8终于将这个特性规范化，在语言层面（使用反射API和Parameter.getName()方法）和字节码层面（使用心得javac编译器以及-parameters参数）提供支持。</span>
					</div>
					<pre>
<code id="ID_1636C202B80" class="lang-java hljs"><ol><li><span class="hljs-keyword">import</span> java.lang.reflect.Method;</li><li><span class="hljs-keyword">import</span> java.lang.reflect.Parameter;</li><li></li><li><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParameterNames</span> </span>{</li><li>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>{</li><li>        Method method = ParameterNames.class.getMethod(<span class="hljs-string">"main"</span>, String[].class);</li><li>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">final</span> Parameter parameter: method.getParameters()){</li><li>            System.out.println(<span class="hljs-string">"Parameter:"</span> + parameter.getName());</li><li>        }</li><li>    }</li><li>}</li></ol></code></pre>
					<div><span style="font-family: 微软雅黑">在Java 8中这个特性是默认关闭的，因此如果不带-parameters参数编译上述代码并运行，则会输出如下结果：</span>
					</div>
					<div><span style="font-family: 微软雅黑">
						<pre>
<code id="ID_1636C21FB1C" class="hljs cos"><span class="hljs-keyword">Parameter</span>: arg0</code></pre></span>
					</div>
					<div><span style="font-family: 微软雅黑">如果带-parameter参数，则会输出如下结果（正确的结果）：</span>
					</div>
					<div><span style="font-family: 微软雅黑">
						<pre>
<code id="ID_1636C221FFD" class="hljs vim">Parameter: <span class="hljs-keyword">args</span></code></pre>
						<div>如果使用Maven进行项目管理，则可以在maven-compiler-plugin编译器的配置项中配置-parameters参数：
						</div></span>
					</div>
					<div><span style="font-family: 微软雅黑">
						<pre>
<code id="ID_1636C24BF96" class="lang-xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">compilerArgument</span>&gt;</span>-parameters<span class="hljs-tag">&lt;/<span class="hljs-name">compilerArgument</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre>
						<div><br />
						</div>
						<div><span style="font-size: 18pt"><strong>三.Java 官方库的新特性</strong></span>
						</div>
						<div>Java 8增加了很多新的工具类（date/time类），并扩展了现存的工具类，以支持现代的并发编程、函数式编程等。
						</div>
						<div><br />
						</div>
						<div><span style="font-size: 13.5pt"><strong>1.Optional</strong></span>
						</div>
						<div>Java应用中最常见的bug就是空值异常。在Java 8之前，Google Guava引入了Optionals类来解决NullPointException，从而避免源码被各种null检查污染，以便开发者写出更加整洁的代码。Java 8也将Optional加入了官方库。
						</div>
						<div><br />
						</div>
						<div>Optional仅仅是一个容器：存放T类型的值或者null。它提供了一些有用的接口来避免显示的null检查。
						</div>
						<div>
							<pre>
<code id="ID_1636C2D3716" class="lang-java hljs">Optional&lt;String&gt; fullName = Optional.ofNullable(<span class="hljs-keyword">null</span>);
System.out.println(<span class="hljs-string">"Full Name is set? "</span> + fullName.isPresent());
System.out.println(<span class="hljs-string">"Full Name: "</span> + fullName.orElseGet(() -&gt; <span class="hljs-string">"[none]"</span>));
System.out.println(fullName.map(s -&gt; <span class="hljs-string">"Hey"</span> + s + <span class="hljs-string">"!"</span>).orElse(<span class="hljs-string">"Hey Stranger!"</span>));</code></pre>
							<div>如果Optional实例持有一个非空值，则isPresent()方法返回true，否则返回false；orElseGet()方法，Optional实例持有null，则可以接受一个lambda表达式生成的默认值；map()方法可以将现有的Optional实例的值转换成新的值；orElse()方法与orElseGet()方法类似，但是在持有null的时候返回传入的默认值。上述代码的输出结果如下：
							</div>
						</div>
						<div>
							<div><span style="font-family: Consolas; font-size: 12pt">Full Name is set? false</span>
							</div>
							<div><span style="font-family: Consolas; font-size: 12pt">Full Name: [none]</span>
							</div>
							<div><span style="font-family: Consolas; font-size: 12pt">Hey Stranger!</span>
							</div>
							<div><br />
							</div>
						</div>
						<div>再看另一个简单的例子：
						</div>
						<div>
							<pre>
<code id="ID_1636C316619" class="lang-java hljs">Optional&lt;String&gt; firstName = Optional.of(<span class="hljs-string">"Tom"</span>);
System.out.println(<span class="hljs-string">"First Name is set? "</span> + firstName.isPresent());
System.out.println(<span class="hljs-string">"First Name: "</span> + firstName.orElseGet(() -&gt; <span class="hljs-string">"[none]"</span>));
System.out.println(firstName.map(s -&gt; <span class="hljs-string">"Hey "</span> + s + <span class="hljs-string">"!"</span>).orElse(<span class="hljs-string">"Hey Stranger!"</span>));</code></pre>
							<div>这个例子的输出是：
							</div>
						</div>
						<div>
							<div><span style="font-family: Consolas; font-size: 12pt">First Name is set? true</span>
							</div>
							<div><span style="font-family: Consolas; font-size: 12pt">First Name: Tom</span>
							</div>
							<div><span style="font-family: Consolas; font-size: 12pt">Hey Tom!</span>
							</div>
						</div>
						<div><span style="font-family: Consolas; font-size: 12pt"><br /></span>
						</div>
						<div><span style="font-size: 13.5pt"><strong>2.Streams</strong></span>
						</div>
						<div><span style="font-size: 12pt; ">新增的Stream API（java.util.stream）将生成环境的函数式编程引入了Java库中。这是目前为止最大的一次对Java库的完善，一遍开发者能够写出更加有效、更加简洁和紧凑的代码</span>
						</div>
						<div><span style="font-size: 12pt; "><br /></span>
						</div>
						<div><span style="font-size: 12pt; ">Stream API极大地简化了集合操作（后面我们会看到不止是集合），首先看下这个叫Task的类：</span>
						</div></span>
						<pre>
<code id="ID_1636C3846B1" class="lang-java hljs"><ol><li><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Streams</span> </span>{</li><li>    </li><li>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> Status{</li><li>        OPEN, CLOSED</li><li>    }</li><li>    </li><li>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span></span>{</li><li>        </li><li>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Status status;</li><li>        </li><li>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer points;</li><li>        </li><li>        Task(<span class="hljs-keyword">final</span> Status status, <span class="hljs-keyword">final</span> Integer points){</li><li>            <span class="hljs-keyword">this</span>.status = status;</li><li>            <span class="hljs-keyword">this</span>.points = points;</li><li>        }</li><li>        </li><li>        <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getPoints</span><span class="hljs-params">()</span></span>{</li><li>            <span class="hljs-keyword">return</span> points;</li><li>        }</li><li>        </li><li>        <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">getStatus</span><span class="hljs-params">()</span></span>{</li><li>            <span class="hljs-keyword">return</span> status;</li><li>        }</li><li>        </li><li>        <span class="hljs-meta">@Override</span></li><li>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{</li><li>            <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">"[%s, %d]"</span>, status, points);</li><li>        }</li><li>    }</li><li>}</li></ol></code></pre>
						<div><span style="font-family: 微软雅黑">Task类有一个分数（或伪复杂度）的概念，另外还有两种状态：OPEN或者CLOSED。现在假设有一个task集合：</span>
						</div>
						<pre>
<code id="ID_1636C3C7B17" class="lang-java hljs"><span class="hljs-keyword">final</span> Collection&lt;Task&gt; tasks = Arrays.asList(
    <span class="hljs-keyword">new</span> Task(Status.OPEN, <span class="hljs-number">5</span>),
    <span class="hljs-keyword">new</span> Task(Status.OPEN, <span class="hljs-number">13</span>),
    <span class="hljs-keyword">new</span> Task(Status.CLOSED, <span class="hljs-number">8</span>)
);</code></pre>
						<div><span style="font-family: 微软雅黑">首先看一个问题：在这个task集合中一共有多少个OPEN状态的点？在Java 8之前，要解决这个问题，则需要使用forEach循环遍历task集合；但是在Java 8中可以利用streams解决：包括一系列元素的列表，并且支持顺序和并行处理。</span>
						</div>
					</div>
					<div>
						<pre style="font-family: 微软雅黑; ">
<code id="ID_1636CB45DDA" class="lang-java hljs"><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> totalPointsOfOpenTasks = tasks.stream().filter(task -&gt; task.getStatus() == Status.OPEN).mapToInt(Task::getPoints).sum();
System.out.println(<span class="hljs-string">"Total points: "</span> + totalPointsOfOpenTasks);</code></pre>
						<div style="font-family: 微软雅黑; ">运行这个方法的控制台输出是：
						</div>
						<div>
							<div>
								<pre style="font-family: Consolas; ">
<code id="ID_1636CB5CC3B" class="hljs vim">Total point<span class="hljs-variable">s:</span> <span class="hljs-number">18</span></code></pre>
								<div><span style="font-family: 微软雅黑">这里有很多知识点值得说。首先，tasks集合被转换成stream表示；其次，在stream上的filter操作会过滤掉所有CLOSED的task；第三，mapToInt操作基于每个task实例的Task::getPoints方法将task流转换成Integer集合；最后，通过sum方法计算总和，得出最后的结果。</span>
								</div>
							</div>
						</div>
						<div><span style="font-family: 微软雅黑"><br /></span>
						</div>
						<div><span style="font-family: 微软雅黑">在学习下一个例子之前，还需要记住一些streams的知识点。Stream之上的操作可分为中间操作和晚期操作。</span>
						</div>
						<div><span style="font-family: 微软雅黑"><br /></span>
						</div>
						<div><span style="font-family: 微软雅黑">中间操作会返回一个新的stream--执行一个中间操作（例如filter）并不会执行实际的过滤操作，而是创建一个新的stream，并将原stream中符合条件的元素放入新的stream。</span>
						</div>
						<div><span style="font-family: 微软雅黑"><br /></span>
						</div>
						<div><span style="font-family: 微软雅黑">晚期操作（例如forEach或者sum），会遍历stream并得出结果或者附带结果；在执行晚期操作之后，stream处理线已经处理完毕，就不能使用了。在几乎所有情况下，晚期操作都是立刻对stream进行遍历。</span>
						</div>
						<div><span style="font-family: 微软雅黑"><br /></span>
						</div>
						<div><span style="font-family: 微软雅黑">stream的另一个价值是创造性地支持并行处理（parallel processing）。对于上述的tasks集合，我们可以用下面的代码计算所有任务的点数之和：</span>
						</div>
						<pre>
<code id="ID_1636CC0B2D9" class="lang-java hljs"><span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> totalPoints = tasks.stream().parallel().map(task -&gt; task.getPoints()).reduce(<span class="hljs-number">0</span>, Integer::sum);
System.out.println(<span class="hljs-string">"Total points (all tasks): "</span> + totalPoints);</code></pre>
						<div><span style="font-family: 微软雅黑">这里我们使用parallel方法进行并行处理所有的task，并使用reduce方法计算最终的结果。控制台输出如下：</span>
						</div>
					</div>
					<div><span style="font-family: 微软雅黑">
						<pre>
<code id="ID_1636CC1AAAF" class="hljs glsl">Total <span class="hljs-keyword">points</span> (<span class="hljs-built_in">all</span> tasks): <span class="hljs-number">26.0</span></code></pre>
						<div>对于一个集合，经常需要根据某些条件对其中的元素分组。利用stream提供的API可以很快完成这类任务，代码如下：
						</div>
						<div>
							<pre>
<code id="ID_1636CC4F16D" class="lang-java hljs"><span class="hljs-keyword">final</span> Map&lt;Status, List&lt;Task&gt;&gt; map = tasks.stream().collect(Collectors.groupingBy(Task::getStatus));
System.out.println(map);</code></pre>
							<div>控制台的输出如下：
							</div>
						</div>
						<div>
							<pre>
<code id="ID_1636CC5697C" class="hljs lua">{CLOSED=<span class="hljs-string">[[CLOSED, 8]]</span>, OPEN=<span class="hljs-string">[[OPEN, 5], [OPEN, 13]]</span>}</code></pre>
							<div>最后一个关于tasks集合的例子问题是：如何计算集合中每个任务的点数在集合中所占的比重，具体处理的代码如下：
							</div>
							<pre>
<code id="ID_1636CCCB96E" class="lang-java hljs"><span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> totalPoints = tasks.stream().parallel().map(task -&gt; task.getPoints()).reduce(<span class="hljs-number">0</span>, Integer::sum);
<span class="hljs-keyword">final</span> Collection&lt;String&gt; result = tasks.stream().mapToInt(Task::getPoints).asLongStream().mapToDouble(points -&gt; points/totalPoints).boxed()
    .mapToLong(weight -&gt; (<span class="hljs-keyword">long</span>)(weight * <span class="hljs-number">100</span>)).mapToObj(percentAge -&gt; percentAge + <span class="hljs-string">"%"</span>).collect(Collectors.toList());
System.out.println(result);</code></pre>
							<div>控制台输出结果如下：
							</div>
						</div>
						<div>
							<pre>
<code id="ID_1636CCD5DBE" class="hljs json">[<span class="hljs-number">19</span>%, <span class="hljs-number">50</span>%, <span class="hljs-number">30</span>%]</code></pre>
							<div>最后，正如之前所说，Stream API不仅可以作用于Java集合，传统的IO操作（从文件或者网络一行一行地读取数据）可以受益于stream处理，这里有一个小例子：
							</div>
						</div>
						<div>
							<pre>
<code id="ID_1636CD2D391" class="lang-java hljs"><span class="hljs-keyword">final</span> Path path = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"d:/InvTask.xml"</span>).toPath();
<span class="hljs-keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(path, StandardCharsets.UTF_8)){
    lines.onClose(() -&gt; System.out.println(<span class="hljs-string">"Done!"</span>)).forEach(System.out::println);
} <span class="hljs-keyword">catch</span> (IOException e) {
    e.printStackTrace();
}</code></pre>
							<div><br />
							</div>
						</div>
						<div><span style="font-size: 13.5pt"><strong>3.Date/Time API（JSR 310）</strong></span>
						</div>
						<div>Java 8引入了新的Date-Time API（JSR 310）来改进时间、日期的额处理。时间和日期的管理一直是最令Java开发者痛苦的问题。java.util.Date和后来的java.util.Calendar一直没有解决这个问题（甚至令开发者更加迷茫）。
						</div>
						<div><br />
						</div>
						<div>因为这些原因，诞生了第三方库Joda-Time，可以替代Java的时间管理API。Java 8中新的时间和日期管理API深受Joda-Time影响，并吸收了很多Joda-Time的精华。新的java.time包包含了所有关于日期、时间、时区、Instant（跟日期类似但是精确到纳秒）、duration（持续时间）和时钟操作的类。新设计的API认真考虑了这些类的不变性（从java.util.Calendar吸取的教训），如果某个实例需要修改，则返回一个新的对象。
						</div>
						<div><br />
						</div>
						<div>我们接下来可以看看java.time包中的关键字和各自的使用例子。首先，Clock类使用时区来返回当前的纳秒时间和日期。Clock可以替代System.currentTimeMillis()和TimeZone.getDefault().
						</div></span>
						<pre>
<code id="ID_1636CDA6170" class="lang-java hljs"><span class="hljs-keyword">final</span> Clock clock = Clock.systemUTC();
System.out.println(clock.instant());
System.out.println(clock.millis());</code></pre>
						<div><span style="font-family: 微软雅黑">运行结果为：</span>
						</div>
						<pre>
<code id="ID_1636CDB3498" class="hljs subunit">2018<span class="hljs-string">-05</span><span class="hljs-string">-17</span>T06:47:01.225Z
1526539621428</code></pre>
						<div><span style="font-family: 微软雅黑">第二，关注下LocalDate和LocalTime类。LocalDate仅仅包含ISO-8601日历系统中的日期部分；LocalTime则仅仅包含该日历系统中的时间部分。这两个类的对象都可以使用Clock对象构建得到。</span>
						</div>
						<pre>
<code id="ID_1636CE0DD71" class="lang-java hljs"><ol><li><span class="hljs-keyword">final</span> Clock clock = Clock.systemUTC();</li><li><span class="hljs-keyword">final</span> LocalDate date = LocalDate.now();</li><li><span class="hljs-keyword">final</span> LocalDate dateFromClock = LocalDate.now(clock);</li><li>System.out.println(date);</li><li>System.out.println(dateFromClock);</li><li>        </li><li><span class="hljs-keyword">final</span> LocalTime time = LocalTime.now();</li><li><span class="hljs-keyword">final</span> LocalTime timeFromClock = LocalTime.now(clock);</li><li>System.out.println(time);</li><li>System.out.println(timeFromClock);</li></ol></code></pre>
						<div>运行结果如下：
						</div>
					</div>
					<div>
						<pre>
<code id="ID_1636CE13F23" class="hljs subunit">2018<span class="hljs-string">-05</span><span class="hljs-string">-17</span>
2018<span class="hljs-string">-05</span><span class="hljs-string">-17</span>
14:53:59.513
06:53:59.513</code></pre>
						<div><span style="font-family: 微软雅黑">LocalDateTime类包含了LocalDate和LocalTime的信息，但是不包含ISO-8601日历系统中的时区信息。这里有一些关于LocalDate和LocalTime的例子：</span>
						</div>
						<pre>
<code id="ID_1636CE4229E" class="lang-java hljs"><span class="hljs-keyword">final</span> Clock clock = Clock.systemUTC();
<span class="hljs-keyword">final</span> LocalDateTime dateTime = LocalDateTime.now();
<span class="hljs-keyword">final</span> LocalDateTime dateTimeFromClock = LocalDateTime.now(clock);
System.out.println(dateTime);
System.out.println(dateTimeFromClock);</code></pre>
						<div><span style="font-family: 微软雅黑">运行结果如下：</span>
						</div>
					</div>
					<div>
						<pre>
<code id="ID_1636CE4AEF9" class="hljs subunit">2018<span class="hljs-string">-05</span><span class="hljs-string">-17</span>T14:58:22.276
2018<span class="hljs-string">-05</span><span class="hljs-string">-17</span>T06:58:22.276</code></pre>
						<div><span style="font-family: 微软雅黑">如果需要特定时区的date/time信息，则可以使用ZoneDateTime，它保存有ISO-8601日期系统的日期和时间，而且有时区信息。下面是一些使用不同时区的例子：</span>
						</div>
						<pre>
<code id="ID_1636CEC795E" class="lang-java hljs"><span class="hljs-keyword">final</span> Clock clock = Clock.systemUTC();
<span class="hljs-keyword">final</span> ZonedDateTime zonedDateTime = ZonedDateTime.now();
<span class="hljs-keyword">final</span> ZonedDateTime zonedDateTimeFromClock = ZonedDateTime.now(clock);
<span class="hljs-keyword">final</span> ZonedDateTime zonedDateTimeFromZone = ZonedDateTime.now(ZoneId.of(<span class="hljs-string">"America/Los_Angeles"</span>));
System.out.println(zonedDateTime);
System.out.println(zonedDateTimeFromClock);
System.out.println(zonedDateTimeFromZone);</code></pre>
						<div><span style="font-family: 微软雅黑">运行结果如下：</span>
						</div>
						<pre>
<code id="ID_1636CECE0FA" class="hljs css">2018<span class="hljs-selector-tag">-05-17T15</span><span class="hljs-selector-pseudo">:06</span><span class="hljs-selector-pseudo">:49.060+08</span><span class="hljs-selector-pseudo">:00</span><span class="hljs-selector-attr">[GMT+08:00]</span>
2018<span class="hljs-selector-tag">-05-17T07</span><span class="hljs-selector-pseudo">:06</span><span class="hljs-selector-pseudo">:49.060Z</span>
2018<span class="hljs-selector-tag">-05-17T00</span><span class="hljs-selector-pseudo">:06</span><span class="hljs-selector-pseudo">:49.123-07</span><span class="hljs-selector-pseudo">:00</span><span class="hljs-selector-attr">[America/Los_Angeles]</span></code></pre>
						<div><span style="font-family: 微软雅黑">最后看下Duration类，它持有的时间精确到秒和纳秒。这使得我们可以很容易地计算两个日期之间你的不同，实例代码如下：</span>
						</div>
					</div>
					<div><span style="font-family: 微软雅黑">
						<pre>
<code id="ID_1636CF06495" class="lang-java hljs"><span class="hljs-keyword">final</span> LocalDateTime from = LocalDateTime.of(<span class="hljs-number">2014</span>, Month.APRIL, <span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-keyword">final</span> LocalDateTime to = LocalDateTime.of(<span class="hljs-number">2015</span>, Month.APRIL, <span class="hljs-number">16</span>, <span class="hljs-number">23</span>, <span class="hljs-number">59</span>, <span class="hljs-number">59</span>);
<span class="hljs-keyword">final</span> Duration duration = Duration.between(from, to);
System.out.println(<span class="hljs-string">"Duration in days: "</span> + duration.toDays());
System.out.println(<span class="hljs-string">"Duration in hours: "</span> + duration.toHours());</code></pre>
						<div>这个例子用于计算2014年4月16日和2015年4月16日之间的天数和小时数，运行结果如下：
						</div>
						<div>
							<pre>
<code id="ID_1636CF10171" class="hljs dart"><span class="hljs-built_in">Duration</span> <span class="hljs-keyword">in</span> days: <span class="hljs-number">365</span>
<span class="hljs-built_in">Duration</span> <span class="hljs-keyword">in</span> hours: <span class="hljs-number">8783</span></code></pre>
							<div><br />
							</div>
						</div>
						<div><span style="font-size: 13.5pt"><strong>4.Nashorn JavaScript引擎</strong></span>
						</div>
						<div>Java 8提供了新的Nashorn JavaScript引擎，使得我们可以在JVM上开发和运行JS应用。Nashorn JavaScript引擎是javax.script.ScriptEngine的另一个实现版本，这类Script引擎遵循相同的规则，允许Java和JavaScript交互使用，实例代码如下：
						</div></span>
						<pre>
<code id="ID_1636CF76BCD" class="lang-java hljs"><ol><li><span class="hljs-keyword">try</span> {</li><li>    ScriptEngineManager manager = <span class="hljs-keyword">new</span> ScriptEngineManager();</li><li>    ScriptEngine engine = manager.getEngineByName(<span class="hljs-string">"JavaScript"</span>);</li><li>    System.out.println(engine.getClass().getName());</li><li>    System.out.println(<span class="hljs-string">"Result: "</span> + engine.eval(<span class="hljs-string">"function f(){return 1;};f()+1;"</span>));</li><li>} <span class="hljs-keyword">catch</span> (ScriptException e) {</li><li>    e.printStackTrace();</li><li>}</li></ol></code></pre>
						<div><span style="font-family: 微软雅黑">运行结果如下：</span>
						</div>
					</div>
					<div>
						<pre>
<code id="ID_1636CF7F28D" class="hljs stylus">jdk<span class="hljs-selector-class">.nashorn</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.scripting</span><span class="hljs-selector-class">.NashornScriptEngine</span>
Result: <span class="hljs-number">2.0</span>
</code></pre>
						<div><br />
						</div>
					</div>
					<div><span style="font-family: 微软雅黑; font-size: 13.5pt"><strong>5.Base64</strong></span>
					</div>
					<div><span style="font-family: 微软雅黑">对Base64编码的支持已经被加入到Java 8官方库中，这样不需要使用第三方库就可以进行Base64编码，实例代码如下：</span>
					</div>
					<pre>
<code id="ID_1636CFD71BB" class="lang-java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    <span class="hljs-keyword">final</span> String text = <span class="hljs-string">"Base64 finally in Java 8!"</span>;
        
    <span class="hljs-keyword">final</span> String encoded = Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));
    System.out.println(encoded);
        
    <span class="hljs-keyword">final</span> String decoded = <span class="hljs-keyword">new</span> String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8);
    System.out.println(decoded);
}</code></pre>
					<div><span style="font-family: 微软雅黑">运行结果如下：</span>
					</div>
					<div>
						<pre>
<code id="ID_1636D055B1C" class="lang-java hljs">QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==
Base64 <span class="hljs-keyword">finally</span> in Java <span class="hljs-number">8</span>!</code></pre>
						<div><br />
						</div>
					</div>
					<div><span style="font-family: 微软雅黑"><span style="font-size: 13.5pt"><strong>6.并行数组</strong></span></span>
					</div>
					<div><span style="font-family: 微软雅黑">Java 8版本新增了很多新的方法，用于支持并行数组处理。最重要的方法是pafallelSort()，可以显著加快多核机器上的数组排序。下面的例子论证了parallexXxx系列的方法：</span>
					</div>
					<pre>
<code id="ID_1636D109376" class="lang-java hljs"><span class="hljs-keyword">long</span>[] arrayOfLong = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">20000</span>];
Arrays.parallelSetAll(arrayOfLong, index -&gt; ThreadLocalRandom.current().nextInt(<span class="hljs-number">1000000</span>));
System.out.print(<span class="hljs-string">"Unsorted: "</span>);
Arrays.stream(arrayOfLong).limit(<span class="hljs-number">10</span>).forEach(i -&gt; System.out.print(i + <span class="hljs-string">" "</span>));
System.out.println();
        
Arrays.parallelSort(arrayOfLong);
System.out.print(<span class="hljs-string">"Sorted: "</span>);
Arrays.stream(arrayOfLong).limit(<span class="hljs-number">10</span>).forEach(i -&gt; System.out.print(i + <span class="hljs-string">" "</span>));</code></pre>
					<div><span style="font-family: 微软雅黑; ">上述这些代码使用parallelSetAll()方法随机生成20000个随机数，然后使用parallelSort()方法进行排序。这个程序会输出乱序数组和排序数组的前10个元素。运行结果如下：</span>
					</div>
					<pre>
<code id="ID_1636D11340C" class="hljs tap">Unsorted:<span class="hljs-number"> 726572 </span>517916<span class="hljs-number"> 860950 </span>977840<span class="hljs-number"> 332301 </span>604647<span class="hljs-number"> 643077 </span>496848<span class="hljs-number"> 81287 </span>891620 
Sorted:<span class="hljs-number"> 5 </span>103<span class="hljs-number"> 118 </span>156<span class="hljs-number"> 172 </span>231<span class="hljs-number"> 260 </span>265<span class="hljs-number"> 286 </span>288 </code></pre>
					<div><br />
					</div>
					<div><span style="font-family: 微软雅黑; font-size: 13.5pt"><strong>7.并发性</strong></span>
					</div>
					<div><span style="font-family: 微软雅黑">基于新增的lambda表达式和stream特性，Java 8中为java.util.concurrent.ConcurrentHashMap类添加了新的方法来支持聚焦操作；另外，也为java.util.concurrentForkJoinPool类添加了新的方法来支持通用线程池操作。</span>
					</div>
					<div><span style="font-family: 微软雅黑"><br /></span>
					</div>
					<div><span style="font-family: 微软雅黑">Java 8还添加了新的java.util.concurrent.locks.StampedLock类，用于支持基于容量的锁--该锁有三个模型用于支持读写操作（可以把这个锁当做是java.util.concurrent.locks.ReadWriteLock的替代者）。</span>
					</div>
					<div><span style="font-family: 微软雅黑"><br /></span>
					</div>
					<div><span style="font-family: 微软雅黑">在java.util.concurrent.atomic包中也新增了不少工具类，列举如下：</span>
					</div>
					<div>
						<ul>
							<li><span style="font-family: 微软雅黑; ">DoubleAccumulator</span>
							</li>
							<li><span style="font-family: 微软雅黑; ">DoubleAdder</span>
							</li>
							<li><span style="font-family: 微软雅黑; ">LongAccumulator</span>
							</li>
							<li><span style="font-family: 微软雅黑; ">LongAdder</span>
							</li>
						</ul>
						<div><span style="font-family: 微软雅黑"><br /></span>
						</div>
					</div>
					<div><span style="font-family: 微软雅黑; font-size: 18pt"><strong>四.新的Java工具</strong></span>
					</div>
					<div><span style="font-family: 微软雅黑">Java 8提供了一些新的命令行工具，这部分会讲解一些对开发者最有用的工具。</span>
					</div>
					<div><span style="font-family: 微软雅黑"><br /></span>
					</div>
					<div><span style="font-family: 微软雅黑; font-size: 13.5pt"><strong>1.Nashorn引擎：jjs</strong></span>
					</div>
					<div><span style="font-family: 微软雅黑">jjs是一个基于标准Nashorn引擎的命令行工具，可以接受js源码并执行。例如，写一个func.js文件，内容如下：</span>
					</div>
					<pre>
<code id="ID_1636D19AC35" class="lang-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

print(f() + <span class="hljs-number">1</span>);</code></pre>
					<div><span style="font-family: 微软雅黑">可以在命令行中执行这个命令：jjs func.js（配置好JDK环境变量，进入func.js目录下），控制台输出结果是2。</span>
					</div>
					<div><span style="font-family: 微软雅黑"><br /></span>
					</div>
					<div><span style="font-family: 微软雅黑; font-size: 13.5pt"><strong>2.类依赖分析器：jdeps</strong></span>
					</div>
					<div><span style="font-family: 微软雅黑">jdeps是一个相当棒的命令行工具，它可以展示包层级和类层级的Java类依赖关系，它以.class文件、目录或者jar文件为输入，然后会把依赖关系输出到控制台。</span>
					</div>
					<div><span style="font-family: 微软雅黑"><br /></span>
					</div>
					<div><span style="font-family: 微软雅黑">我们可以利用jedps分下下Spring Framework库，为了让结果少一点，仅仅分析一个Jar文件：</span>
					</div>
					<pre>
<code id="ID_1636D1DFDFF" class="hljs stylus">jdeps d:/org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.core-3</span>.<span class="hljs-number">1.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span></code></pre>
					<div><span style="font-family: 微软雅黑">这个命令会输出很多结果，我们仅看下其中的一部分：依赖关系按照包分组，如果在classpath上找不到依赖，则显示“not found”</span>
					</div>
					<div><span style="font-family: 微软雅黑">
						<pre>
<code id="ID_1636D2207D5" class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.xml</span> (org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.core-3</span>.<span class="hljs-number">1.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span>)
   -&gt; java<span class="hljs-selector-class">.io</span>
   -&gt; java<span class="hljs-selector-class">.lang</span>
   -&gt; java<span class="hljs-selector-class">.util</span>
   -&gt; javax<span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.namespace</span>
   -&gt; javax<span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.stream</span>
   -&gt; javax<span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.stream</span><span class="hljs-selector-class">.events</span>
   -&gt; javax<span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.stream</span><span class="hljs-selector-class">.util</span>
   -&gt; javax<span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.transform</span>
   -&gt; javax<span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.transform</span><span class="hljs-selector-class">.sax</span>
   -&gt; javax<span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.transform</span><span class="hljs-selector-class">.stax</span>
   -&gt; org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.commons</span><span class="hljs-selector-class">.logging</span>                         找不到
   -&gt; org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.util</span>                           org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.core-3</span>.<span class="hljs-number">1.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span>
   -&gt; org<span class="hljs-selector-class">.w3c</span><span class="hljs-selector-class">.dom</span>
   -&gt; org<span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.sax</span>
   -&gt; org<span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.sax</span><span class="hljs-selector-class">.ext</span>
   -&gt; org<span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.sax</span><span class="hljs-selector-class">.helpers</span></code></pre>
						<div><br />
						</div>
						<div><span style="font-size: 18pt"><strong>五.JVM的新特性</strong></span>
						</div>
						<div>使用Metaspace（JEP 122）代替持久代（PermGen space）。在JVM参数方面，使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize.
						</div></span>
					</div>
					<div>
					</div>
				</div>
				<div style="font-family: 微软雅黑; ">
				</div>
			</div>
		</div>
	</body>
</html>
