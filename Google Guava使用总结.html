<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<link rel="stylesheet" type="text/css" href="file:///${exe}/scripts/highlight.styles/${SyntaxHighlightStyleName}.css" />
		<style>
			body, table{font-family: 微软雅黑}
			
			table{border-collapse: collapse; border: 1px solid gray; border-width: 2px 1px 2px 1px;}
			th{border: 1px solid gray; padding: 4px; background-color: #ddd;}
			td{border: 1px solid gray; padding: 4px;}
			tr:nth-child(2n){background-color: #f8f8f8;}
			pre{border: 2px solid #d6d6d6; padding: 0px; border-radius: 3px;}
		</style>
	</head>
	<body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">
		<div><span style="font-size: large; font-weight: bold;">1.Stopwatch（计时器）</span>
		</div>
		<div>我们经常需要判断某一段语句执行需要多少时间，过去常用的做法是记录运行前的时间，然后用运行完成的时间减去运行前的时间，并且转换成我们可读的秒或毫秒时间，在guava中的做法是：
		</div>
		<div>
			<pre>
<code id="ID_162FA72783A" class="lang-java hljs"><ol><li><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;</li><li></li><li><span class="hljs-keyword">import</span> com.google.common.base.Stopwatch;</li><li></li><li><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span></li><li>{</li><li>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span></li><li>    {</li><li>        Stopwatch stopwatch = Stopwatch.createStarted();</li><li>        <span class="hljs-keyword">try</span></li><li>        {</li><li>            TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);</li><li>        }</li><li>        <span class="hljs-keyword">catch</span> (InterruptedException e)</li><li>        {</li><li>            e.printStackTrace();</li><li>        }</li><li>        <span class="hljs-keyword">long</span> nanos = stopwatch.elapsed(TimeUnit.SECONDS);</li><li>        System.out.println(nanos);</li><li>    }</li><li>}</li></ol></code></pre>
			<div><br />
			</div>
		</div>
		<div><span style="font-size: large; font-weight: bold;">2.String Spliting字符串分割</span>
		</div>
		<div>有这样一组字符串&quot;hello,,test,com&quot;，我们用split(&quot;,&quot;)分割字符串，得到的结果是[&quot;hello&quot;,&quot;&quot;,&quot;test&quot;,&quot;com&quot;]，但是我们希望去掉空值，还需要另外处理，使用guava的Splitter可以做到
		</div>
		<div>
			<pre>
<code id="ID_162FAA86E8E" class="lang-java hljs">Iterable&lt;String&gt; split = Splitter.on(<span class="hljs-string">','</span>).trimResults().omitEmptyStrings().split(<span class="hljs-string">"hello,,test,com"</span>);
<span class="hljs-keyword">for</span>(Iterator&lt;String&gt; iterator = split.iterator(); iterator.hasNext();){
    System.out.println(iterator.next());
}</code></pre>
			<div>更加高级的用法：
			</div>
		</div>
		<div>
			<pre>
<code id="ID_162FAABE98B" class="lang-java hljs">String str = <span class="hljs-string">"key1:1;key2:2;key3:3"</span>;
Map&lt;String, String&gt; map = Splitter.on(<span class="hljs-string">';'</span>).trimResults().withKeyValueSeparator(<span class="hljs-string">":"</span>).split(str);
System.out.println(map);</code></pre>
			<div>结果：
			</div>
		</div>
		<div>
			<pre>
<code id="ID_162FAAC5003" class="lang-java hljs">{key1=<span class="hljs-number">1</span>, key2=<span class="hljs-number">2</span>, key3=<span class="hljs-number">3</span>}</code></pre>
			<div><br />
			</div>
		</div>
		<div><span style="font-size: 13.5pt"><strong>3.字符串处理CharMatcher</strong></span>
		</div>
		<div>如果想从字符串中得到所有的数字，guava可以这样处理:
		</div>
		<div>
			<pre>
<code id="ID_162FAB0BB96" class="lang-java hljs">String str = CharMatcher.DIGIT.retainFrom(<span class="hljs-string">"some text 4324 and more 23"</span>);
System.out.println(str);</code></pre>
			<div>结果为：432423
			</div>
		</div>
		<div><br />
		</div>
		<div>如果想把字符串中的数字都去掉，guava可以这样处理：
		</div>
		<div>
			<pre>
<code id="ID_162FAB1E940" class="lang-java hljs">String str = CharMatcher.DIGIT.removeFrom(<span class="hljs-string">"some text 4324 and more 23"</span>);
System.out.println(str);</code></pre>
			<div>结果为：<span style="font-family: Consolas; font-size: 16px; ">some text &nbsp;and more</span>
			</div>
			<div><br />
			</div>
			<div><span style="font-size: 13.5pt"><strong>4.基本类型的便捷工具类</strong></span>
			</div>
			<div>假如有一个整型数组，我们想知道数组中是否有特定的整型数字。传统的写法如下：
			</div>
			<div>
				<pre>
<code id="ID_162FABA5E1A" class="lang-java hljs"><span class="hljs-keyword">int</span>[] array = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
<span class="hljs-keyword">int</span> a = <span class="hljs-number">4</span>;
<span class="hljs-keyword">boolean</span> hasA = <span class="hljs-keyword">false</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i: array){
    <span class="hljs-keyword">if</span>(i == a){
        hasA = <span class="hljs-keyword">true</span>;
    }
}</code></pre>
				<div>使用guava，我们可以简化代码：
				</div>
			</div>
			<div>
				<pre>
<code id="ID_162FABBB477" class="lang-java hljs"><span class="hljs-keyword">boolean</span> contains = Ints.contains(array, a);</code></pre>
				<div>同样，其他类型的基本数组也可以这么来做。我们甚至可以直接对数组做如下操作：
				</div>
			</div>
			<div>
				<pre>
<code id="ID_162FABD15E9" class="lang-java hljs"><span class="hljs-keyword">int</span> indexOf = Ints.indexOf(array, a);
<span class="hljs-keyword">int</span> max = Ints.max(array);
<span class="hljs-keyword">int</span> min = Ints.min(array);
<span class="hljs-keyword">int</span>[] concat = Ints.concat(array, array2);</code></pre>
				<div>各种类型都定义在com.google.common.primitives包下面，包含Boolean、Bytes、Chars、Doubles、Floats、Ints、Longs、Shorts、SignedBytes、UnsignedBytes、UnsignedInteger、UnsignedInts、UnsignedLong、UnsignedLongs类
				</div>
			</div>
			<div><br />
			</div>
			<div><span style="font-size: 13.5pt"><strong>5.简化的集合用法</strong></span>
			</div>
			<div>以前定义Map这么写
			</div>
			<div>
				<pre>
<code id="ID_162FAC255BA" class="lang-java hljs">Map&lt;String, Map&lt;Long, List&lt;String&gt;&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Map&lt;Long, List&lt;String&gt;&gt;&gt;();
</code></pre>
				<div>现在使用guava可以这么写：
				</div>
			</div>
			<div>
				<pre>
<code id="ID_162FAC2F081" class="lang-java hljs">Map&lt;String, Map&lt;Long, List&lt;String&gt;&gt;&gt; map = Maps.newHashMap();</code></pre>
				<div>或者直接使用静态导入：
				</div>
			</div>
			<div>
				<pre>
<code id="ID_162FAC3A94A" class="lang-java hljs">Map&lt;String, Map&lt;Long, List&lt;String&gt;&gt;&gt; map = new HashMap();</code></pre>
				<div>同样的：
				</div>
			</div>
			<div>
				<pre>
<code id="ID_162FAC50DAB" class="lang-java hljs">Lists.newArrayList();
Sets.newHashSet();</code></pre>
				<div>构造数据以前是这样的：
				</div>
			</div>
			<div>
				<pre>
<code id="ID_162FAC5E889" class="lang-java hljs">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();
list.add(<span class="hljs-string">"a"</span>);
list.add(<span class="hljs-string">"b"</span>);
list.add(<span class="hljs-string">"c"</span>);
list.add(<span class="hljs-string">"d"</span>);</code></pre>
				<div>现在用guava可以这样写：
				</div>
			</div>
			<div>
				<pre>
<code id="ID_162FAC81409" class="lang-java hljs">ImmutableList&lt;String&gt; list = ImmutableList.of(<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"d"</span>);
ImmutableMap&lt;String, String&gt; map = ImmutableMap.of(<span class="hljs-string">"key1"</span>, <span class="hljs-string">"value1"</span>, <span class="hljs-string">"key2"</span>, <span class="hljs-string">"value2"</span>);</code></pre>
				<div><br />
				</div>
			</div>
			<div><span style="font-size: 13.5pt"><strong>6.便捷的文件读取</strong></span>
			</div>
			<div>从文件中按行读取内容
			</div>
			<div>
				<pre>
<code id="ID_162FAD2E11C" class="lang-java hljs">File file = <span class="hljs-keyword">new</span> File(getClass().getResource(<span class="hljs-string">"/test.txt"</span>).getFile());
List&lt;String&gt; lines = Files.readLines(file, Charsets.UTF_8);</code></pre>
				<div><br />
				</div>
			</div>
			<div><span style="font-size: 13.5pt"><strong>7.强大的Function对象转换</strong></span>
			</div>
			<div>假设有一个Map，key是物品，value是对应的价格，单位是欧元。若有个需求是将里面的价格都转换为美元，传统的做法是遍历整个Map，然后更新每个value值，将价格转换为美元价格。现在通过Function只需要这样写即可：
			</div>
			<div>
				<pre>
<code id="ID_162FAE2DFE5" class="lang-java hljs">Map&lt;String, Double&gt; usdPriceMap = Maps.transformValues(eurPriceMap, <span class="hljs-keyword">new</span> Function&lt;Double, Double&gt;(){
    <span class="hljs-keyword">double</span> eurToUsd = <span class="hljs-number">1.4888</span>;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">apply</span><span class="hljs-params">(Double from)</span></span>{
        <span class="hljs-keyword">return</span> from * eurToUsd;
    }
});</code></pre>
				<div><br />
				</div>
			</div>
			<div><span style="font-size: 13.5pt"><strong>8.Ordering实现复杂的排序</strong></span>
			</div>
			<div>对集合进行排序我们可以使用JDK提供的Collections类：Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;)；但有时候我们想做更复杂的一些事情，比如合并多个Comparator或者我们可能只是想要排序的集合的一个视图，而不改变原来集合的顺序。Guava给我们提供了Ordering，让我们更好地掌控排序。加入我们有两个对Person类排序的comparator，一个是根据lastName排序，一个是根据firstName排序：
			</div>
			<div>
				<pre>
<code id="ID_162FB759FB7" class="lang-java hljs">Comparator&lt;Person&gt; byLastName = <span class="hljs-keyword">new</span> Comparator&lt;Person&gt;(){
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person p1, Person p2)</span></span>{
        <span class="hljs-keyword">return</span> p1.getLastName().compareTo(p2.getLastName());
    }
};
        
Comparator&lt;Person&gt; byFirstName = <span class="hljs-keyword">new</span> Comparator&lt;Person&gt;(){
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person p1, Person p2)</span></span>{
        <span class="hljs-keyword">return</span> p1.getFirstName().compareTo(p2.getFirstName());
    }
};</code></pre>
				<div>那么，假如我们现在想先根据lastName排序，再根据firstName排序，然后对排序的结果反序，那么guava可以这么简化：
				</div>
				<div>
					<pre>
<code id="ID_162FB785402" class="lang-java hljs">List&lt;Person&gt; sortedCopy = Ordering.from(byLastName).compound(byFirstName).reverse().sortedCopy(person);</code></pre>
					<div><br />
					</div>
				</div>
			</div>
			<div><span style="font-size: 13.5pt"><strong>9.集合的交集、并集和差集</strong></span>
			</div>
			<div>交集：
			</div>
			<div>
				<pre>
<code id="ID_162FB864BC1" class="lang-java hljs">SetView&lt;Integer&gt; intersection = Sets.intersection(setA, setB);
<span class="hljs-keyword">for</span>(Integer integer: intersection)
    System.out.println(integer);</code></pre>
			</div>
			<div>并集：
			</div>
			<div>
				<pre>
<code id="ID_162FB82E390" class="lang-java hljs">Set&lt;Integer&gt; setA = Sets.newHashSet(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);
Set&lt;Integer&gt; setB = Sets.newHashSet(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);
SetView&lt;Integer&gt; union = Sets.union(setA, setB);
<span class="hljs-keyword">for</span>(Integer integer: union)
    System.out.println(integer);</code></pre>
				<div>差集：
				</div>
			</div>
			<div>
				<pre>
<code id="ID_162FB8510D0" class="lang-java hljs">SetView&lt;Integer&gt; difference = Sets.difference(setA, setB);
<span class="hljs-keyword">for</span>(Integer integer: difference)
    System.out.println(integer);</code></pre>
				<div>输出：1,2,3
				</div>
			</div>
			<div><br />
			</div>
			<div>对于Map，可以像下面这样处理：
			</div>
			<div>
				<pre>
<code id="ID_162FB87C013" class="lang-java hljs">MapDifference differenceMap = Maps.difference(mapA, mapB);</code></pre>
				<div>如果用MapDifference类，我们还可以这样：
				</div>
			</div>
			<div>
				<pre>
<code id="ID_162FB8A41AC" class="lang-java hljs">differenceMap.areEqual();
Map entriesDiffering = differenceMap.entriesDiffering();
Map entriesOnlyOnLeft = differenceMap.entriesOnlyOnLeft();
Map entriesOnlyOnRight = differenceMap.entriesOnlyOnRight();
Map entriesInCommon = differenceMap.entriesInCommon();</code></pre>
				<div><br />
				</div>
			</div>
			<div><span style="font-size: 13.5pt"><strong>10.一键多值Map--Multimap</strong></span>
			</div>
			<div>以前这样实现：
			</div>
			<div>
				<pre>
<code id="ID_162FB919912" class="lang-java hljs">Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();
        
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addStr</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String key, <span class="hljs-keyword">final</span> String value)</span></span>{
    List&lt;String&gt; lists = map.get(key);
    <span class="hljs-keyword">if</span>(lists == <span class="hljs-keyword">null</span>){
        lists = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();
        lists.add(value);
    }
    map.put(key, lists);
}</code></pre>
				<div>现在用guava可以这样写：
				</div>
			</div>
			<div>
				<pre>
<code id="ID_162FB93B7DA" class="lang-java hljs">Multimap&lt;String, String&gt; multimap = ArrayListMultimap.create();
        
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addStr</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String key, <span class="hljs-keyword">final</span> String value)</span></span>{
    multimap.put(key, value);
}</code></pre>
				<div><br />
				</div>
			</div>
			<div><span style="font-size: 13.5pt"><strong>11.集合重组</strong></span>
			</div>
			<div>
				<pre>
<code id="ID_162FB9FD3F3" class="lang-java hljs">List&lt;Map&lt;String, String&gt;&gt; listOfMaps = Lists.newArrayList();
ImmutableMap&lt;String, String&gt; map = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++){
    map = ImmutableMap.of(<span class="hljs-string">"type"</span>,<span class="hljs-string">"blog"</span>,<span class="hljs-string">"id"</span>,<span class="hljs-string">"10"</span>+(i+<span class="hljs-number">1</span>),<span class="hljs-string">"author"</span>,<span class="hljs-string">"join"</span>+(i+<span class="hljs-number">1</span>));
    listOfMaps.add(map);
}
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++){
    map = ImmutableMap.of(<span class="hljs-string">"type"</span>,<span class="hljs-string">"news"</span>,<span class="hljs-string">"id"</span>,<span class="hljs-string">"20"</span>+(i+<span class="hljs-number">1</span>),<span class="hljs-string">"author"</span>,<span class="hljs-string">"hugh"</span>+(i+<span class="hljs-number">1</span>));
    listOfMaps.add(map);
}</code></pre>
				<div><br />
				</div>
			</div>
		</div>
	</body>
</html>
