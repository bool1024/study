<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<style>
			body, table{font-family: 微软雅黑}
			
			table{border-collapse: collapse; border: 1px solid gray; border-width: 2px 1px 2px 1px;}
			th{border: 1px solid gray; padding: 4px; background-color: #ddd;}
			td{border: 1px solid gray; padding: 4px;}
			tr:nth-child(2n){background-color: #f8f8f8;}
			pre{border: 2px solid #d6d6d6; padding: 0px; border-radius: 3px;}
		</style>
	</head>
	<body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">
		<div><span style="font-size: 18pt"><strong>
			<div style="color: rgb(0, 0, 0); font-family: 'Microsoft YaHei'; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;">
				<p><span style="font-family: SimHei; font-size: 24px;">1、单例模式的设计思想</span>
				</p>
				<div align="left" style="font-size: 16px; font-family: 微软雅黑; text-indent: 28px;"><span style="color: rgb(51, 51, 51); font-family: SimSun; font-size: 14px;">在上面我们说到现在解决问题的关键就是保证在应用中只有一个对象就行了，那么怎么保证只有一个对象呢？</span>
				</div>
				<p><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">其实只需要三步就可以保证对象的唯一性</span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">(1)不允许其他程序用new对象。</span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">&nbsp; &nbsp; 因为new就是开辟新的空间，在这里更改数据只是更改的所创建的对象的数据，如果可以new的话，每一次new都产生一个对象，这样肯定保证不了对象的唯一性。</span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">(2)在该类中创建对象<br />&nbsp; &nbsp;因为不允许其他程序new对象，所以这里的对象需要在本类中new出来</span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">(3)对外提供一个可以让其他程序获取该对象的方法</span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">&nbsp; &nbsp;因为对象是在本类中创建的，所以需要提供一个方法让其它的类获取这个对象。</span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">那么这三步怎么用代码实现呢？将上述三步转换成代码描述是这样的</span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">(1)私有化该类的构造函数<br />(2)通过new在</span><span style="font-family: SimSun; font-size: 14px;"><span style="color: rgb(255, 0, 0);">本</span></span><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">类中创建一个本类对象<br />(3)定义一个公有的方法，将在该类中所创建的对象返回</span>
				</p>
				<p><span style="color: rgb(51, 51, 51);"><br /><span style="font-family: SimHei; font-size: 24px;">2、单例模式的写法</span></span>
				</p>
				<p><span style="color: rgb(51, 51, 51);"><span style="font-size: 14px;"><span style="font-family: SimSun;">&nbsp; &nbsp;经过3中的分析我们理解了单例所解决的问题以及它的实现思想，接着来看看它的实现代码，单例模式的写法大的方面可以分为5种<span style="line-height: 18px;">五种①懒汉式②饿汉式③双重校验锁④静态内部类⑤枚举</span>。接下来我们就一起来看看这几种单例设计模式的代码实现，以及它们的优缺点</span></span></span>
				</p>
				<div align="left" style="text-indent: 28px;"><span style="font-family: SimHei; font-size: 18px;">2.1单例模式的饿汉式[可用]</span>
				</div>
				<div align="left" style="font-family: 微软雅黑; text-indent: 28px;"><span style="font-family: Consolas;"><span style="font-size: 18px;"></span></span>
					<pre class="java">
public class Singleton {

	private static Singleton instance=new Singleton();
	private Singleton(){};
	public static Singleton getInstance(){
		return instance;
	}
}</pre>
				</div>
				<p><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">访问方式</span>
				</p>
				<p>
				</p>
				<pre class="java">
Singleton instance = Singleton.getInstance();</pre>
				<p><span style="font-family: SimSun; font-size: 14px;"><span style="color: rgb(255, 0, 0);">得到这个实例后就可以访问这个类中的方法了。</span></span>
				</p>
				<p>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px;"><span style="color: rgb(51, 51, 51);">优点：从它的实现中我们可以看到，这种方式的实现比较简单，在类加载的时候就完成了实例化，避免了线程的同步问题。</span></span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px;"><span style="color: rgb(51, 51, 51);">缺点：由于在类加载的时候就实例化了，所以没有达到Lazy Loading(懒加载)的效果，也就是说可能我没有用到这个实例，但是它</span></span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px;"><span style="color: rgb(51, 51, 51);">也会加载，会造成内存的浪费(但是这个浪费可以忽略，所以这种方式也是推荐使用的)。</span></span>
				</p><span style="font-size: 18px;"><span style="font-family: Consolas;">&nbsp;<span>&nbsp;2</span></span><span style="font-family: SimHei;">.2单例模式的饿汉式变换写法[可用]</span></span>
			</div>
			<div style="color: rgb(0, 0, 0); font-family: 'Microsoft YaHei'; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><span style="font-family: Consolas; font-size: 18px;"></span>
				<pre class="java">
public class Singleton{

	private static Singleton instance = null;
	
	static {
		instance = new Singleton();
	}

	private Singleton() {};

	public static Singleton getInstance() {
		return instance;
	}
}</pre>
				<div align="left" style="text-indent: 28px;"><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);"></span>
					<p><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">访问方式：</span>
					</p>
					<p>
					</p>
					<pre class="java">
Singleton instance = Singleton.getInstance();</pre>
					<p>
					</p>
					<p style="margin-top: 0px; margin-bottom: 1.5em; padding-top: 0px; padding-bottom: 0px; border: 0px; line-height: 27.5938px; vertical-align: baseline; background-color: rgb(248, 248, 248);"><span style="font-family: SimSun; font-size: 14px; color: rgb(255, 0, 0);">得到这个实例后就可以访问这个类中的方法了。</span>
					</p>
					<p style="margin-top: 0px; margin-bottom: 1.5em; padding-top: 0px; padding-bottom: 0px; border: 0px; line-height: 27.5938px; vertical-align: baseline; background-color: rgb(248, 248, 248);"><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);">可以看到上面的代码是按照在2中分析的那三步来实现的，这中写法被称为饿汉式，因为它在类创建的时候就已经实例化了对象。</span><span style="background-color: rgb(255, 255, 255);">其实2.2和2.1只是写法有点不同，都是在类初始化时创建对象的，它的优缺点和2.1一样，可以归为一种写法。</span>
					</p>
					<p style="margin-top: 0px; margin-bottom: 1.5em; padding-top: 0px; padding-bottom: 0px; border: 0px; line-height: 27.5938px; vertical-align: baseline; background-color: rgb(248, 248, 248);"><span style="font-family: SimHei; font-size: 18px; background-color: rgb(255, 255, 255);">2.3单例模式的懒汉式[线程不安全，不可用]</span>
					</p>
				</div>
			</div>
			<div style="color: rgb(0, 0, 0); font-family: 'Microsoft YaHei'; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><span style="font-family: Consolas;"><span style="font-size: 19px;"></span></span>
				<pre class="java">
public class Singleton {

	private static Singleton instance=null;
	
	private Singleton() {};
	
	public static Singleton getInstance(){
		
		if(instance==null){
			instance=new Singleton();
		}
		return instance;
	}
}</pre>
				<p>
				</p>
				<div align="left" style="text-indent: 28px;">
					<div align="left"><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">这种方式是在调用getInstance方法的时候才创建对象的，所以它比较懒因此被称为懒汉式。</span>
					</div>
					<div align="left"><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">在上述两种写法中懒汉式其实是存在线程安全问题的，喜欢刨根问题的同学可能会问，存在怎样的线程安全问题？怎样导致这种问题的？好，我们来说一下什么情况下这种写法会有问题。在运行过程中可能存在这么一种情况：有多个线程去调用getInstance方法来获取Singleton的实例，那么就有可能发生这样一种情况当第一个线程在执行if(instance==null)这个语句时，此时instance是为null的进入语句。在还没有执行instance=new Singleton()时(此时<span style="color: rgb(51, 51, 51); font-family: SimSun; font-size: 14px; text-indent: 28px;">instance是为null的)</span>第二个线程也进入if(instance==null)这个语句，因为之前进入这个语句的线程中还没有执行<span style="color: rgb(51, 51, 51); font-family: SimSun; font-size: 14px; text-indent: 28px;">instance</span>=new Singleton()，所以它会执行<span style="color: rgb(51, 51, 51); font-family: SimSun; font-size: 14px; text-indent: 28px;">instance</span>=new Singleton()来实例化Singleton对象，因为第二个线程也进入了if语句所以它也会实例化Singleton对象。这样就导致了实例化了两个Singleton对象。所以单例模式的懒汉式是存在线程安全问题的，既然它存在问题，那么可能有解决这个问题的方法，那么究竟怎么解决呢？对这种问题可能很多人会想到加锁于是出现了下面这种写法。</span>
					</div>
					<div align="left"><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);"><br /></span>
					</div>
				</div>
				<p><span style="font-family: SimHei; font-size: 18px;">2.4懒汉式线程安全的[线程安全，效率低不推荐使用]</span>
				</p>
				<p><span style="font-family: SimHei; font-size: 18px;"></span>
				</p>
				<pre class="java">
public class Singleton {

	private static Singleton instance=null;
	
	private Singleton() {};
	
	public static synchronized Singleton getInstance(){
		
		if(instance==null){
			instance=new Singleton();
		}
		return instance;
	}
}</pre>
				<p>
				</p>
				<div align="left" style="text-indent: 28px;">
					<div align="left"><span style="line-height: 27.5938px; text-indent: 0px; background-color: rgb(248, 248, 248);"><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</span></span>
					</div>
					<div align="left"><span style="background-color: rgb(248, 248, 248); font-family: SimHei; font-size: 18px; line-height: 27.5938px; text-indent: 0px;">2.5单例模式懒汉式[线程不安全，不可用]</span>
					</div>
					<div align="left"><span style="color: rgb(51, 51, 51); font-family: SimSun; font-size: 14px; background-color: rgb(248, 248, 248); line-height: 27.5938px;">对于上述缺陷的改进可能有的人会想到如下的代码</span>
					</div>
					<div align="left"><span style="line-height: 27.5938px; background-color: rgb(248, 248, 248);"><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);"></span></span>
						<pre class="java">
public class Singleton7 {

	private static Singleton instance=null;
	
	public static Singleton getInstance() {
		if (instance == null) {
			synchronized (Singleton.class) {
				instance = new Singleton();
			}
		}
		return instance;
	}
}</pre>其实这种写法跟4.3一样是线程不安全的，当一个线程还没有实例化Singleton时另一个线程执行到if(instance==null)这个判断语句时就会进入if语句，虽然加了锁，但是等到第一个线程执行完instance=new Singleton()跳出这个锁时，另一个进入if语句的线程同样会实例化另外一个Singleton对象，线程不安全的原理跟4.3类似。因此这种改进方式并不可行，经过大神们一步一步的探索，写出了懒汉式的双重校验锁。<br />
					</div>
					<div align="left"><br />
					</div>
				</div>
				<p><span style="font-family: SimHei; font-size: 18px;">2.6单例模式懒汉式双重校验锁[推荐用]</span>
				</p>
				<p><span style="font-family: SimHei; font-size: 18px;"></span>
				</p>
				<pre class="java">
public class Singleton {
	/**
	 * 懒汉式变种，属于懒汉式中最好的写法，保证了：延迟加载和线程安全
	 */
	private static Singleton instance=null;
	
	private Singleton() {};
	
	public static Singleton getInstance(){
		 if (instance == null) {  
	          synchronized (Singleton.class) {  
	              if (instance == null) {  
	            	  instance = new Singleton();  
	              }  
	          }  
	      }  
	      return instance;  
	}
}</pre>
				<div style="text-indent: 28px;">
					<div align="left">
						<p><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">访问方式</span>
						</p>
						<p>
						</p>
						<pre class="java">
Singleton instance = Singleton.getInstance();</pre>
						<p><span style="font-family: SimSun; font-size: 14px;"><span style="color: rgb(255, 0, 0);">得到这个实例后就可以访问这个类中的方法了。</span></span>
						</p>
						<p><span style="font-family: SimSun; font-size: 14px;"><span style="color: rgb(51, 51, 51);">Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (instance== null)检查，这样就可以保 &nbsp; &nbsp;</span></span><span style="color: rgb(51, 51, 51); font-family: SimSun; font-size: 14px;">证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (instance== null)，直接return实例化对象。</span>
						</p>
						<p><span style="color: rgb(51, 51, 51); font-family: SimSun; font-size: 14px;">优点：线程安全；延迟加载；效率较高。</span>
						</p>
					</div>
				</div>
				<p><span style="line-height: 24px;"><span style="font-family: SimHei; font-size: 18px;">2.7内部类[推荐用]</span></span>
				</p>
				<p><span style="line-height: 24px;"><span style="font-family: SimHei; font-size: 18px;"></span></span>
				</p>
				<pre class="java">
public class Singleton{

	
	private Singleton() {};
	
	private static class SingletonHolder{
		private static Singleton instance=new Singleton();
	} 
	
	public static Singleton getInstance(){
		return SingletonHolder.instance;
	}
}</pre>
				<p>
				</p>
				<p style="margin-top: 0px; margin-bottom: 1.5em; padding-top: 0px; padding-bottom: 0px; border: 0px; line-height: 27.5938px; vertical-align: baseline; background-color: rgb(248, 248, 248);"><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);"></span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51);">访问方式</span>
				</p>
				<p>
				</p>
				<pre class="java">
Singleton instance = Singleton.getInstance();</pre>
				<p><span style="font-family: SimSun; font-size: 14px;"><span style="color: rgb(255, 0, 0);">得到这个实例后就可以访问这个类中的方法了。</span><br /></span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px;"><span style="color: rgb(51, 51, 51);">&nbsp; &nbsp; 这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同</span></span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px;"><span style="color: rgb(51, 51, 51);">的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时</span></span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px;"><span style="color: rgb(51, 51, 51);">并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonHolder类，从而完成Singleton的实例化。</span></span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px;"><span style="color: rgb(51, 51, 51);">类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是</span></span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px;"><span style="color: rgb(51, 51, 51);">无法进入的。</span></span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px;"><span style="color: rgb(51, 51, 51);">优点：避免了线程不安全，延迟加载，效率高。</span></span>
				</p><span style="line-height: 24px;"><span style="font-family: SimHei; font-size: 18px;">2.8枚举[极推荐使用]</span></span>
			</div>
			<div style="color: rgb(0, 0, 0); font-family: 'Microsoft YaHei'; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><span style="line-height: 24px;"><span style="color: rgb(51, 51, 51);"></span></span>
				<pre class="java" style="font-family: SimHei; font-size: 18px;">
public enum SingletonEnum {
	
	 instance; 
	 
	 private SingletonEnum() {}
	 
	 public void method(){
	 }
}</pre>
				<p><span style="line-height: 24px;"><span style="color: rgb(51, 51, 51);"><span style="line-height: 27.5938px; background-color: rgb(248, 248, 248);"><span style="font-family: SimSun; font-size: 14px;">访问方式</span></span></span></span>
				</p>
				<p><span style="line-height: 24px;"><span style="color: rgb(51, 51, 51);"><span style="line-height: 27.5938px; background-color: rgb(248, 248, 248);"><span style="font-family: SimSun; font-size: 14px;"></span></span></span></span>
				</p>
				<pre class="java">
SingletonEnum.instance.method();</pre>
				<p>
				</p>
				<p><span style="line-height: 24px;"><span style="color: rgb(51, 51, 51);"><span style="line-height: 27.5938px; background-color: rgb(248, 248, 248);"><span style="font-family: SimSun; font-size: 14px;">可以看到枚举的书写非常简单，访问也很简单在这里SingletonEnum.instance这里的instance即为SingletonEnum类型的引用所以得到它就可以调用枚举中的方法了。</span></span></span></span>
				</p>
				<p><span style="line-height: 24px;"><span style="color: rgb(51, 51, 51);"><span style="line-height: 27.5938px; background-color: rgb(248, 248, 248);"><span style="font-family: SimSun; font-size: 14px;">借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，很少见人这么写过，这种方式也是最好的一种方式，如果在开发中JDK满足要求的情况下建议使用这种方式。</span></span></span></span>
				</p>
				<p><span style="line-height: 24px;"><span style="line-height: 27.5938px; background-color: rgb(248, 248, 248);"><span style="font-family: SimHei; font-size: 24px;">3、总结</span></span></span>
				</p>
				<p><span style="font-family: SimSun; font-size: 14px;"><span style="line-height: 27.5938px;"><span style="color: rgb(51, 51, 51);">&nbsp; &nbsp; &nbsp;在真正的项目开发中一般采用4.1、4.6、4.7、4.8看你最喜欢哪种写法了，一般情况下这几种模式是没有问题的，为了装逼我一般采用4.6这种写法，我们经常用的</span><span style="line-height: 35px;"><span style="font-family: 'microsoft yahei'; font-size: 15px;">Android-Universal-Image-Loader</span><span style="color: rgb(51, 51, 51);">这个开源项目也是采用的4.6这种写法，其实最安全的写法是4.8即枚举，它的实现非常简单而且最安全可谓很完美，但是可能是因为只支持JDK1.5吧又或者是因为枚举大家不熟悉所以目前使用的人并不多，但是大家可以尝试下。另外当我们使用反射机制时可能不能保证实例的唯一性，但是枚举始终可以保证唯一性，具体请参考次博客：<a href="http://blog.csdn.net/java2000_net/article/details/3983958">http://blog.csdn.net/java2000_net/article/details/3983958</a>但是一般情况下很少遇到这种情况。</span></span></span></span>
				</p><span style="line-height: 24px;"><span style="font-family: SimHei; font-size: 24px;">4、单例模式的在面试中的问题</span></span>
			</div>
			<div style="color: rgb(0, 0, 0); font-family: 'Microsoft YaHei'; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><span style="line-height: 24px;"><span style="font-family: SimHei; font-size: 24px;"><br /></span></span>
			</div>
			<p style="color: rgb(0, 0, 0); font-family: 'Microsoft YaHei'; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);">&nbsp; &nbsp; &nbsp;单例模式在面试中会常常的被遇到，因为它是考擦一个程序员的基础的扎实程度的，如果说你跟面试官说你做过项目，面试官让你写几个单例设计模式，你写不出来，你觉着面试官会相信吗？在面试时一定要认真准备每一次面试，靠忽悠即使你被录取了，你也很有可能会对这个公司不满意，好了我们言归正传，其实单例设计模式在面试中很少有人会问饿汉式写法，一般都会问单例设计模式的懒汉式的线程安全问题，所以大家一定要充分理解单例模式的线程安全的问题，就这几种模式花点时间，认真学透，面试中遇到任何关于单例模式的问题你都不会害怕是吧。</span>
			</p>
			<div><span style="font-family: SimSun; font-size: 14px; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);"><br /></span>
			</div></strong></span>
		</div>
		<div>
			<ol>
			</ol>
		</div>
	</body>
</html>
